<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dill's 3D Benchmark</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #121212;
            margin: 0;
            overflow: auto;
            color: #eaeaea;
        }

        h1, h3 {
            color: #4caf50;
        }

        /* Styling the score and FPS to make them more visible */
        #score, #fps {
            margin-top: 10px;
            font-size: 1.5em;
            color: #4caf50; /* Green for visibility */
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6); /* Darker background for contrast */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); /* Subtle shadow for emphasis */
        }

        /* Add a rounded box for the warning message */
        #warningMessage {
            color: red;
            font-weight: bold;
            background-color: rgba(255, 0, 0, 0.1); /* Light red background */
            border: 2px solid red;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            width: 80%;
            text-align: center;
            font-size: 1.1em;
        }

        button {
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }

        button:hover {
            background-color: #45a049;
        }

        canvas {
            visibility: hidden; /* Hide the canvas visually */
            position: absolute; /* Take it out of the layout flow */
            width: 0; /* Prevent it from taking up space */
            height: 0; /* Prevent it from taking up space */
        }

        #startButton {
            margin-bottom: 20px;
        }

        #exampleScoresButton {
            margin-top: 10px;
        }

        #space {
            margin-top: 10px;
        }

        /* Version styling */
        #version {
            margin-top: 20px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>

<div id="space">⠀</div>
<h1>Dill's 3D Benchmark</h1>
<h3>Benchmark completes when the FPS drops below 5.</h3>
<h3>Results are exponential, a device that scores twice as high is many times more powerful, not just double.</h3>
<canvas id="gpuCanvas" width="100" height="100"></canvas>
<h5>Make sure to keep the tab in focus and/or device screen awake for the duration of the test.</h5>

<!-- Score and FPS inside styled boxes -->
<h4><div id="score">Score: N/A</div></h4>
<h4><div id="fps">FPS: N/A</div></h4>

<!-- Red warning message -->
<div id="warningMessage">
  Warning: This benchmark is resource-intensive and may affect device performance during testing.
</div>

<div id="warningMessage">
  Your device may heat up during this benchmark!
</div>

<div id="space">⠀</div>
<button id="startButton" onclick="startBenchmark()">Start Benchmark</button>
<div id="space">⠀</div>
<button id="exampleScoresButton" onclick="window.location.href='https://benchmark.dill.moe/scores'">Example Scores</button>
<div id="space">⠀</div>
<div id="version">Version: 1.0.4</div>

<script>
    let renderer, shapes = [], lastRenderTime = performance.now();
    let score = 0, frameCount = 0, fpsSum = 0, warmUpFrames = 1;
    const shapesPerBatch = 1000;
    const fpsHistory = [];

    class WebGPURenderer {
        async init(canvas) {
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("Could not find a suitable GPUAdapter");
            }
            this.device = await adapter.requestDevice();
            this.canvas = canvas;
            this.context = this.canvas.getContext('webgpu');

            this.format = navigator.gpu.getPreferredCanvasFormat();
            this.context.configure({
                device: this.device,
                format: this.format,
                alphaMode: 'opaque'
            });

            await this.createPipeline();
            this.vertexBuffer = this.device.createBuffer({
                size: 36 * 6 * Float32Array.BYTES_PER_ELEMENT,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });

            this.vertexArrayBuffer = this.createBuffer(shapes);
        }

        async createPipeline() {
            const shaderModule = this.device.createShaderModule({
                code: `
					@vertex
					fn vs_main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4<f32> {
						let positions = array<vec3<f32>, 18>(
							vec3<f32>(-1.0, -1.0,  1.0), vec3<f32>( 1.0,  1.0,  1.0), vec3<f32>(-1.0,  1.0,  1.0),
							vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0,  1.0, -1.0), vec3<f32>( 1.0,  1.0, -1.0),
							vec3<f32>(-1.0,  1.0,  1.0), vec3<f32>(-1.0,  1.0, -1.0), vec3<f32>( 1.0,  1.0,  1.0),
							vec3<f32>( 1.0,  1.0, -1.0), vec3<f32>( 1.0, -1.0,  1.0), vec3<f32>( 1.0, -1.0, -1.0),
							vec3<f32>(-1.0, -1.0,  1.0), vec3<f32>( 1.0, -1.0,  1.0), vec3<f32>(-1.0, -1.0, -1.0),
							vec3<f32>( 1.0, -1.0, -1.0), vec3<f32>( 1.0,  1.0, -1.0), vec3<f32>(-1.0,  1.0, -1.0)
						);
						let vertexIndex = i32(VertexIndex);
						return vec4<f32>(positions[vertexIndex], 1.0);
					}

					@fragment
					fn fs_main() -> @location(0) vec4<f32> {
						return vec4<f32>(1.0, 0.0, 0.0, 1.0);
					}
                `
            });

            this.pipeline = this.device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main'
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [{
                        format: this.format
                    }]
                }
            });
        }

        createShape() {
            return {
                position: [Math.random() * 10 - 5, Math.random() * 6 - 3, -10],
                color: [Math.random(), Math.random(), Math.random(), 1.0],
                rotation: 0,
                rotationSpeed: Math.random() * 0.05 // Added for CPU load calculation
            };
        }

        // Calculate a rotation matrix for extra CPU work
        static calculateRotationMatrix(angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [
                [cos, 0, sin],
                [0, 1, 0],
                [-sin, 0, cos]
            ];
        }

        applyTransformations(shapes) {
            // Perform heavy rotation calculations for each shape
            shapes.forEach(shape => {
                shape.rotation += shape.rotationSpeed;
                const rotationMatrix = WebGPURenderer.calculateRotationMatrix(shape.rotation);
                
                // Apply rotation matrix to shape's position vector
                shape.position = shape.position.map((coord, index) => {
                    return rotationMatrix[index].reduce((acc, val, i) => acc + val * shape.position[i], 0);
                });
            });
        }

        createBuffer(shapes) {
            const vertices = [
                -1, -1,  1,  1,  1,  1,  -1,  1,  1,
                -1, -1, -1,  -1,  1, -1,   1,  1, -1,
                -1,  1,  1,  -1,  1, -1,   1,  1,  1,
                1,  1, -1,   1, -1, 1,   1, -1, -1,
                -1, -1,  1,   1, -1,  1,  -1, -1, -1,
                1, -1, -1,    1,  1, -1,  -1,  1, -1,
            ];

            const verticesArray = [];
            for (const shape of shapes) {
                const offset = shape.position;
                for (let j = 0; j < vertices.length; j += 3) {
                    verticesArray.push(vertices[j] + offset[0]);
                    verticesArray.push(vertices[j + 1] + offset[1]);
                    verticesArray.push(vertices[j + 2] + offset[2]);
                }
            }

            this.device.queue.writeBuffer(this.vertexBuffer, 0, new Float32Array(verticesArray));
            return this.vertexBuffer;
        }

        render(shapes, deltaTime) {
            const commandEncoder = this.device.createCommandEncoder();

            const textureView = this.context.getCurrentTexture().createView();

            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView,
                    loadOp: 'clear',
                    storeOp: 'store',
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }
                }]
            };

            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setPipeline(this.pipeline);
            passEncoder.setVertexBuffer(0, this.vertexBuffer);
            passEncoder.draw(18, shapes.length);
            passEncoder.end();

            this.device.queue.submit([commandEncoder.finish()]);
        }
    }

    async function startBenchmark() {
        document.getElementById('startButton').style.display = 'none';
        document.getElementById('score').innerText = 'Starting benchmark...';

        const canvas = document.getElementById('gpuCanvas');

        try {
            renderer = new WebGPURenderer();
            await renderer.init(canvas);
        } catch (e) {
            console.log('WebGPU not available:', e);
            document.getElementById('score').innerText = 'WebGPU not available';
            return;
        }

        shapes = [renderer.createShape()];
        score = 1;
        frameCount = 0;
        fpsSum = 0;
        fpsHistory.length = 0;

        requestAnimationFrame(renderLoop);
    }

    function renderLoop(now) {
        const deltaTime = now - lastRenderTime;
        lastRenderTime = now;

        frameCount++;
        const fps = 1000 / deltaTime;

        fpsHistory.push({ fps, timestamp: now });

        while (fpsHistory.length > 0 && now - fpsHistory[0].timestamp > 1000) {
            fpsHistory.shift();
        }

        if (frameCount > warmUpFrames) {
            const totalFPS = fpsHistory.reduce((sum, entry) => sum + entry.fps, 0);
            const avgFPS = totalFPS / fpsHistory.length;

            document.getElementById('fps').innerText = 'FPS: ' + Math.round(avgFPS);

            if (avgFPS < 5) {
                document.getElementById('score').innerText = 'Final Score: ' + ((shapes.length - 1) / 10) + ' points';
                return;
            }

            document.getElementById('score').innerText = 'Score: ' + ((shapes.length - 1) / 10);
        }

        renderer.applyTransformations(shapes);
        renderer.render(shapes, deltaTime);

        for (let i = 0; i < shapesPerBatch; i++) {
            shapes.push(renderer.createShape());
        }

        requestAnimationFrame(renderLoop);
    }
</script>

</body>
</html>
