<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dill's 3D Shape Benchmark</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #121212;
            margin: 0;
            overflow: auto;
            color: #eaeaea;
        }

        h1, h3 {
            color: #4caf50;
        }

        #score, #fps, #space, #version {
            margin-top: 10px;
            font-size: 1.2em;
            color: #aaa;
        }

        button {
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #45a049;
        }

        canvas { 
            border: 1px solid #555;
            background-color: #1c1c1c;
        }

        #startButton {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

<h1>Dill's 3D Shape Benchmark</h1>
<h3>Benchmark completes when avg FPS drops below 15.</h3>
<canvas id="gpuCanvas" width="600" height="400"></canvas>
<div id="score">Score: N/A</div>
<div id="fps">FPS: N/A</div>
<div id="space">⠀</div>
<div id="version">Version: 1.0.2</div>
<div id="space">⠀</div>
<button id="startButton" onclick="startBenchmark()">Start Benchmark</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
<script>
    let renderer, shapes = [], lastRenderTime = performance.now();
    let score = 0, frameCount = 0, fpsSum = 0, warmUpFrames = 60;
    const shapesPerBatch = 20;

	class WebGLRenderer {
		async init(canvas) {
			this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
			if (!this.gl) {
				throw new Error("WebGL is not supported");
			}

			// Disable face culling to render both sides of each cube
			this.gl.disable(this.gl.CULL_FACE);

			this.gl.enable(this.gl.DEPTH_TEST);
			this.gl.clearColor(0.0, 0.0, 0.0, 1.0);

			await this.createProgram();
			return true;
		}

		async createProgram() {
			const vertexShaderSource = `
				attribute vec4 aPosition;
				uniform mat4 uModelViewProjectionMatrix;
				uniform vec4 uColor;
				varying lowp vec4 vColor;
				void main() {
					gl_Position = uModelViewProjectionMatrix * aPosition;
					vColor = uColor;
				}
			`;

			const fragmentShaderSource = `
				varying lowp vec4 vColor;
				void main() {
					gl_FragColor = vColor;
				}
			`;

			const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexShaderSource);
			const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);

			this.program = this.gl.createProgram();
			this.gl.attachShader(this.program, vertexShader);
			this.gl.attachShader(this.program, fragmentShader);
			this.gl.linkProgram(this.program);

			if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
				throw new Error("Unable to initialize the shader program");
			}

			this.gl.useProgram(this.program);

			// Get uniform locations
			this.uniformLocations = {
				modelViewProjectionMatrix: this.gl.getUniformLocation(this.program, "uModelViewProjectionMatrix"),
				color: this.gl.getUniformLocation(this.program, "uColor")
			};

			// Get attribute locations
			this.attributeLocations = {
				position: this.gl.getAttribLocation(this.program, "aPosition")
			};
		}

		compileShader(type, source) {
			const shader = this.gl.createShader(type);
			this.gl.shaderSource(shader, source);
			this.gl.compileShader(shader);

			if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
				console.error("Error compiling shader:", this.gl.getShaderInfoLog(shader));
				this.gl.deleteShader(shader);
				return null;
			}
			return shader;
		}

		createCube() {
			const vertices = new Float32Array([
				// Front face
				-1, -1,  1,  1,  1,  1,  -1,  1,  1,
				-1, -1, -1,  -1,  1, -1,   1,  1, -1,
				-1,  1,  1,  -1,  1, -1,   1,  1,  1,
				1,  1, -1,   1, -1,  1,   1, -1, -1,
				-1, -1,  1,   1, -1,  1,  -1, -1, -1,
				1, -1, -1,    1,  1, -1,  -1,  1, -1,
			]);

			return {
				position: [Math.random() * 6 - 3, Math.random() * 4 - 2, -6],  // Random position in 3D space
				color: [Math.random(), Math.random(), Math.random(), 1.0],  // Random color
				rotation: 0, // Initialize rotation angle
				vertices: vertices
			};
		}

		createBuffer(shapes) {
			// Prepare a large array to hold vertices for all shapes
			const verticesArray = [];
			for (let i = 0; i < shapes.length; i++) {
				const cube = shapes[i];
				const offset = cube.position;

				// Transform cube's vertices based on its position
				for (let j = 0; j < cube.vertices.length; j += 3) {
					verticesArray.push(cube.vertices[j] + offset[0]);
					verticesArray.push(cube.vertices[j + 1] + offset[1]);
					verticesArray.push(cube.vertices[j + 2] + offset[2]);
				}
			}

			const buffer = this.gl.createBuffer();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(verticesArray), this.gl.STATIC_DRAW);
			return buffer;
		}

		render(shapes, deltaTime) {
			this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

			const viewMatrix = mat4.create();
			mat4.lookAt(viewMatrix, [0, 0, 15], [0, 0, 0], [0, 1, 0]);

			// Create a large buffer containing all shapes' vertices
			const buffer = this.createBuffer(shapes);

			// Bind and set up vertex attribute pointers
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
			this.gl.vertexAttribPointer(this.attributeLocations.position, 3, this.gl.FLOAT, false, 0, 0);
			this.gl.enableVertexAttribArray(this.attributeLocations.position);

			// Set up projection matrix (this defines the camera's perspective)
			const projectionMatrix = mat4.create();
			mat4.perspective(projectionMatrix, Math.PI / 4, this.gl.canvas.width / this.gl.canvas.height, 0.1, 100.0);

			// Render each cube individually with its own transformation
			for (const cube of shapes) {
				// Increment the rotation for the cube for each frame
				cube.rotation += deltaTime * 0.001;

				// Create model matrix for each cube (its own local transformation)
				const modelMatrix = mat4.create();
				mat4.translate(modelMatrix, modelMatrix, cube.position);  // Positioning
				mat4.rotate(modelMatrix, modelMatrix, cube.rotation, [0, 1, 0]);  // Rotation

				// Combine the projection, view, and model matrices to form the final MVP matrix
				const mvpMatrix = mat4.create();
				mat4.multiply(mvpMatrix, projectionMatrix, viewMatrix); // MVP = P * V
				mat4.multiply(mvpMatrix, mvpMatrix, modelMatrix); // MVP = MVP * M

				// Set uniforms for each cube
				this.gl.uniformMatrix4fv(this.uniformLocations.modelViewProjectionMatrix, false, mvpMatrix);
				this.gl.uniform4fv(this.uniformLocations.color, cube.color);

				// Draw each cube separately with the correct transformation
				this.gl.drawArrays(this.gl.TRIANGLES, shapes.indexOf(cube) * 36, 36); // Each cube has 36 vertices
			}
		}
	}

    async function startBenchmark() {
        document.getElementById('startButton').style.display = 'none';
        document.getElementById('score').innerText = 'Benchmarking...';

        const canvas = document.getElementById('gpuCanvas');
        
        try {
            renderer = new WebGLRenderer();
            await renderer.init(canvas);
        } catch (e) {
            console.log('WebGL not available:', e);
        }

        shapes = [renderer.createCube()];
        score = 1;
        frameCount = 0;
        fpsSum = 0;

        requestAnimationFrame(renderLoop);
    }

    function renderLoop(now) {
        const deltaTime = now - lastRenderTime;
        lastRenderTime = now;

        frameCount++;
        fpsSum += 1000 / deltaTime;

        if (frameCount % 1 === 0) {
            const avgFPS = fpsSum / frameCount;
            document.getElementById('fps').innerText = `FPS: ${Math.round(avgFPS)}`;
        }

        if (frameCount > warmUpFrames) {
            const avgFPS = fpsSum / frameCount;
            if (avgFPS < 15) {
                document.getElementById('score').innerText = 'Final Score: ' + shapes.length + ' shapes';
                return;
            }

            document.getElementById('score').innerText = 'Shapes: ' + shapes.length;
            frameCount = 0;
            fpsSum = 0;
        }

        renderer.render(shapes, deltaTime);

        if (frameCount % 1 === 0) {
            for (let i = 0; i < shapesPerBatch; i++) {
                shapes.push(renderer.createCube());
            }
        }

        requestAnimationFrame(renderLoop);
    }
</script>

</body>
</html>
